
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package practicacompiladores;

import java_cup.runtime.*;
import Symbols.*;
import SymbolsTable.*;
import Exceptions.*;
import java.io.FileReader;
import java.util.ArrayList;
import SymbolsTable.TypeDescription;
import SymbolsTable.TypeDescription.CONTENT_DESCRIPTION;
import SymbolsTable.TypeDescription.BASIC_SUBJACENT_TYPE;
import digraph.*;
import BackendCompiler.Quadruple.*;
import java.util.UUID;
import java.util.Stack;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\115\000\002\002\004\000\002\002\004\000\002\003" +
    "\002\000\002\004\004\000\002\004\003\000\002\005\003" +
    "\000\002\005\003\000\002\005\003\000\002\005\003\000" +
    "\002\005\003\000\002\005\003\000\002\005\003\000\002" +
    "\005\003\000\002\005\003\000\002\033\005\000\002\033" +
    "\011\000\002\034\003\000\002\034\002\000\002\036\006" +
    "\000\002\006\005\000\002\007\005\000\002\007\005\000" +
    "\002\010\005\000\002\010\004\000\002\010\003\000\002" +
    "\011\003\000\002\011\002\000\002\035\003\000\002\035" +
    "\003\000\002\035\004\000\002\035\003\000\002\035\003" +
    "\000\002\035\006\000\002\035\003\000\002\035\003\000" +
    "\002\037\007\000\002\027\005\000\002\030\005\000\002" +
    "\030\003\000\002\031\003\000\002\031\005\000\002\031" +
    "\003\000\002\031\003\000\002\032\007\000\002\012\003" +
    "\000\002\013\002\000\002\014\002\000\002\015\003\000" +
    "\002\016\003\000\002\017\014\000\002\020\015\000\002" +
    "\020\002\000\002\021\012\000\002\021\003\000\002\022" +
    "\004\000\002\023\015\000\002\023\007\000\002\024\012" +
    "\000\002\024\003\000\002\050\013\000\002\051\016\000" +
    "\002\025\002\000\002\026\002\000\002\040\012\000\002" +
    "\041\007\000\002\042\003\000\002\042\002\000\002\043" +
    "\007\000\002\043\005\000\002\044\003\000\002\044\002" +
    "\000\002\045\005\000\002\045\002\000\002\046\006\000" +
    "\002\047\005\000\002\047\003\000\002\052\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\300\000\022\005\uffff\010\uffff\014\uffff\015\uffff\016" +
    "\uffff\020\uffff\022\uffff\036\uffff\001\002\000\022\005\020" +
    "\010\022\014\033\015\032\016\016\020\023\022\010\036" +
    "\021\001\002\000\004\002\006\001\002\000\004\002\001" +
    "\001\002\000\032\002\ufff4\005\ufff4\010\ufff4\012\ufff4\014" +
    "\ufff4\015\ufff4\016\ufff4\017\ufff4\020\ufff4\022\ufff4\026\ufff4" +
    "\036\ufff4\001\002\000\004\023\277\001\002\000\032\002" +
    "\ufff9\005\ufff9\010\ufff9\012\ufff9\014\ufff9\015\ufff9\016\ufff9" +
    "\017\ufff9\020\ufff9\022\ufff9\026\ufff9\036\ufff9\001\002\000" +
    "\032\002\ufff5\005\ufff5\010\ufff5\012\ufff5\014\ufff5\015\ufff5" +
    "\016\ufff5\017\ufff5\020\ufff5\022\ufff5\026\ufff5\036\ufff5\001" +
    "\002\000\032\002\ufffa\005\ufffa\010\ufffa\012\ufffa\014\ufffa" +
    "\015\ufffa\016\ufffa\017\ufffa\020\ufffa\022\ufffa\026\ufffa\036" +
    "\ufffa\001\002\000\010\011\254\013\256\026\255\001\002" +
    "\000\032\002\ufffc\005\ufffc\010\ufffc\012\ufffc\014\ufffc\015" +
    "\ufffc\016\ufffc\017\ufffc\020\ufffc\022\ufffc\026\ufffc\036\ufffc" +
    "\001\002\000\004\036\237\001\002\000\032\002\ufffd\005" +
    "\ufffd\010\ufffd\012\ufffd\014\ufffd\015\ufffd\016\ufffd\017\ufffd" +
    "\020\ufffd\022\ufffd\026\ufffd\036\ufffd\001\002\000\004\023" +
    "\037\001\002\000\012\004\ufff0\027\133\031\146\032\132" +
    "\001\002\000\004\023\177\001\002\000\004\023\171\001" +
    "\002\000\032\002\ufff7\005\ufff7\010\ufff7\012\ufff7\014\ufff7" +
    "\015\ufff7\016\ufff7\017\ufff7\020\ufff7\022\ufff7\026\ufff7\036" +
    "\ufff7\001\002\000\004\024\156\001\002\000\024\002\000" +
    "\005\020\010\022\014\033\015\032\016\016\020\023\022" +
    "\010\036\021\001\002\000\032\002\ufff8\005\ufff8\010\ufff8" +
    "\012\ufff8\014\ufff8\015\ufff8\016\ufff8\017\ufff8\020\ufff8\022" +
    "\ufff8\026\ufff8\036\ufff8\001\002\000\032\002\ufff6\005\ufff6" +
    "\010\ufff6\012\ufff6\014\ufff6\015\ufff6\016\ufff6\017\ufff6\020" +
    "\ufff6\022\ufff6\026\ufff6\036\ufff6\001\002\000\032\002\ufffb" +
    "\005\ufffb\010\ufffb\012\ufffb\014\ufffb\015\ufffb\016\ufffb\017" +
    "\ufffb\020\ufffb\022\ufffb\026\ufffb\036\ufffb\001\002\000\004" +
    "\023\uffc4\001\002\000\004\023\uffb5\001\002\000\004\023" +
    "\037\001\002\000\004\023\uffd1\001\002\000\004\025\uffd5" +
    "\001\002\000\012\023\054\025\050\036\056\041\051\001" +
    "\002\000\004\025\041\001\002\000\022\005\uffc4\010\uffc4" +
    "\014\uffc4\015\uffc4\016\uffc4\020\uffc4\022\uffc4\036\uffc4\001" +
    "\002\000\022\005\uffd4\010\uffd4\014\uffd4\015\uffd4\016\uffd4" +
    "\020\uffd4\022\uffd4\036\uffd4\001\002\000\022\005\020\010" +
    "\022\014\033\015\032\016\016\020\023\022\010\036\021" +
    "\001\002\000\024\005\020\010\022\014\033\015\032\016" +
    "\016\020\023\022\010\026\uffc3\036\021\001\002\000\004" +
    "\026\047\001\002\000\032\002\ufffe\005\ufffe\010\ufffe\012" +
    "\ufffe\014\ufffe\015\ufffe\016\ufffe\017\ufffe\020\ufffe\022\ufffe" +
    "\026\ufffe\036\ufffe\001\002\000\032\002\uffc6\005\uffc6\010" +
    "\uffc6\012\uffc6\014\uffc6\015\uffc6\016\uffc6\017\uffc6\020\uffc6" +
    "\022\uffc6\026\uffc6\036\uffc6\001\002\000\022\020\023\021" +
    "\075\023\076\035\064\036\066\037\uffe7\040\074\041\067" +
    "\001\002\000\006\024\uffda\034\uffda\001\002\000\006\024" +
    "\063\034\061\001\002\000\006\024\uffd7\034\uffd7\001\002" +
    "\000\012\023\054\025\050\036\056\041\051\001\002\000" +
    "\006\024\uffdb\034\uffdb\001\002\000\006\024\uffd8\034\uffd8" +
    "\001\002\000\006\024\060\034\061\001\002\000\006\024" +
    "\uffd9\034\uffd9\001\002\000\012\023\054\025\050\036\056" +
    "\041\051\001\002\000\006\024\uffdc\034\uffdc\001\002\000" +
    "\016\024\uffdd\025\uffdd\026\uffdd\027\uffdd\030\uffdd\033\uffdd" +
    "\001\002\000\004\037\uffe8\001\002\000\004\037\124\001" +
    "\002\000\014\024\uffe0\026\uffe0\027\uffe0\030\uffe0\033\uffe0" +
    "\001\002\000\014\024\uffe2\026\uffe2\027\uffe2\030\uffe2\033" +
    "\uffe2\001\002\000\004\033\121\001\002\000\014\024\uffe6" +
    "\026\uffe6\027\uffe6\030\uffe6\033\uffe6\001\002\000\014\024" +
    "\uffe5\026\uffe5\027\uffe5\030\uffe5\033\uffe5\001\002\000\014" +
    "\024\uffdf\026\uffdf\027\uffdf\030\uffdf\033\uffdf\001\002\000" +
    "\014\024\uffe3\026\uffe3\027\uffe3\030\uffe3\033\uffe3\001\002" +
    "\000\004\023\116\001\002\000\016\023\103\025\050\035" +
    "\064\036\100\037\uffe7\041\051\001\002\000\004\037\115" +
    "\001\002\000\010\024\uffd8\034\uffd8\035\uffe9\001\002\000" +
    "\004\035\113\001\002\000\006\024\112\035\106\001\002" +
    "\000\016\023\103\025\050\035\064\036\100\037\uffe7\041" +
    "\051\001\002\000\006\024\105\035\106\001\002\000\006" +
    "\024\uffeb\035\uffeb\001\002\000\012\023\110\035\064\036" +
    "\111\037\uffe7\001\002\000\006\024\uffed\035\uffed\001\002" +
    "\000\012\023\110\035\064\036\111\037\uffe7\001\002\000" +
    "\006\024\uffe9\035\uffe9\001\002\000\014\024\uffee\026\uffee" +
    "\027\uffee\030\uffee\033\uffee\001\002\000\012\023\110\035" +
    "\064\036\111\037\uffe7\001\002\000\006\024\uffec\035\uffec" +
    "\001\002\000\006\024\uffea\035\uffea\001\002\000\004\036" +
    "\117\001\002\000\004\024\120\001\002\000\014\024\uffe1" +
    "\026\uffe1\027\uffe1\030\uffe1\033\uffe1\001\002\000\022\020" +
    "\023\021\075\023\076\035\064\036\066\037\uffe7\040\074" +
    "\041\067\001\002\000\004\026\123\001\002\000\006\024" +
    "\uffd6\034\uffd6\001\002\000\014\024\uffe4\026\uffe4\027\uffe4" +
    "\030\uffe4\033\uffe4\001\002\000\004\023\126\001\002\000" +
    "\004\036\130\001\002\000\004\023\037\001\002\000\010" +
    "\004\ufff0\027\133\032\132\001\002\000\004\004\135\001" +
    "\002\000\004\004\ufff1\001\002\000\004\036\130\001\002" +
    "\000\034\002\ufff3\005\ufff3\010\ufff3\012\ufff3\014\ufff3\015" +
    "\ufff3\016\ufff3\017\ufff3\020\ufff3\022\ufff3\023\ufff3\026\ufff3" +
    "\036\ufff3\001\002\000\004\036\136\001\002\000\004\031" +
    "\137\001\002\000\022\020\023\021\075\023\076\035\064" +
    "\036\066\037\uffe7\040\074\041\067\001\002\000\004\030" +
    "\141\001\002\000\034\002\ufff2\005\ufff2\010\ufff2\012\ufff2" +
    "\014\ufff2\015\ufff2\016\ufff2\017\ufff2\020\ufff2\022\ufff2\023" +
    "\ufff2\026\ufff2\036\ufff2\001\002\000\004\030\143\001\002" +
    "\000\004\036\145\001\002\000\004\024\151\001\002\000" +
    "\004\031\146\001\002\000\022\020\023\021\075\023\076" +
    "\035\064\036\066\037\uffe7\040\074\041\067\001\002\000" +
    "\004\030\150\001\002\000\034\002\uffef\005\uffef\010\uffef" +
    "\012\uffef\014\uffef\015\uffef\016\uffef\017\uffef\020\uffef\022" +
    "\uffef\024\uffef\026\uffef\036\uffef\001\002\000\004\025\152" +
    "\001\002\000\022\005\020\010\022\014\033\015\032\016" +
    "\016\020\023\022\010\036\021\001\002\000\024\005\020" +
    "\010\022\014\033\015\032\016\016\020\023\022\010\026" +
    "\uffc3\036\021\001\002\000\004\026\155\001\002\000\032" +
    "\002\uffc5\005\uffc5\010\uffc5\012\uffc5\014\uffc5\015\uffc5\016" +
    "\uffc5\017\uffc5\020\uffc5\022\uffc5\026\uffc5\036\uffc5\001\002" +
    "\000\004\025\157\001\002\000\026\005\uffc4\010\uffc4\014" +
    "\uffc4\015\uffc4\016\uffc4\017\uffc4\020\uffc4\022\uffc4\026\uffc4" +
    "\036\uffc4\001\002\000\026\005\020\010\022\014\033\015" +
    "\032\016\016\017\uffbb\020\023\022\010\026\uffbb\036\021" +
    "\001\002\000\026\005\020\010\022\014\033\015\032\016" +
    "\016\017\uffbc\020\023\022\010\026\uffbc\036\021\001\002" +
    "\000\006\017\164\026\uffb9\001\002\000\004\026\uffc3\001" +
    "\002\000\022\020\023\021\075\023\076\035\064\036\066" +
    "\037\uffe7\040\074\041\067\001\002\000\004\030\166\001" +
    "\002\000\004\026\uffba\001\002\000\004\026\170\001\002" +
    "\000\032\002\uffc2\005\uffc2\010\uffc2\012\uffc2\014\uffc2\015" +
    "\uffc2\016\uffc2\017\uffc2\020\uffc2\022\uffc2\026\uffc2\036\uffc2" +
    "\001\002\000\004\036\173\001\002\000\006\024\174\027" +
    "\175\001\002\000\006\024\uffb6\027\uffb6\001\002\000\042" +
    "\002\uffb8\005\uffb8\010\uffb8\012\uffb8\014\uffb8\015\uffb8\016" +
    "\uffb8\017\uffb8\020\uffb8\022\uffb8\024\uffb8\026\uffb8\027\uffb8" +
    "\030\uffb8\033\uffb8\036\uffb8\001\002\000\022\020\023\021" +
    "\075\023\076\035\064\036\066\037\uffe7\040\074\041\067" +
    "\001\002\000\006\024\uffb7\027\uffb7\001\002\000\022\020" +
    "\023\021\075\023\076\035\064\036\066\037\uffe7\040\074" +
    "\041\067\001\002\000\004\024\201\001\002\000\004\025" +
    "\202\001\002\000\010\011\uffc9\013\uffc9\026\uffc9\001\002" +
    "\000\004\025\204\001\002\000\022\005\uffc4\010\uffc4\014" +
    "\uffc4\015\uffc4\016\uffc4\020\uffc4\022\uffc4\036\uffc4\001\002" +
    "\000\022\005\uffd4\010\uffd4\014\uffd4\015\uffd4\016\uffd4\020" +
    "\uffd4\022\uffd4\036\uffd4\001\002\000\022\005\020\010\022" +
    "\014\033\015\032\016\016\020\023\022\010\036\021\001" +
    "\002\000\024\005\020\010\022\014\033\015\032\016\016" +
    "\020\023\022\010\026\uffc3\036\021\001\002\000\004\026" +
    "\211\001\002\000\036\002\uffce\005\uffce\006\uffce\007\uffce" +
    "\010\uffce\012\uffce\014\uffce\015\uffce\016\uffce\017\uffce\020" +
    "\uffce\022\uffce\026\uffce\036\uffce\001\002\000\036\002\uffd3" +
    "\005\uffd3\006\uffb5\007\uffb5\010\uffd3\012\uffd3\014\uffd3\015" +
    "\uffd3\016\uffd3\017\uffd3\020\uffd3\022\uffd3\026\uffd3\036\uffd3" +
    "\001\002\000\032\002\uffd0\005\uffd0\010\uffd0\012\uffd0\014" +
    "\uffd0\015\uffd0\016\uffd0\017\uffd0\020\uffd0\022\uffd0\026\uffd0" +
    "\036\uffd0\001\002\000\006\006\uffd2\007\uffd2\001\002\000" +
    "\032\002\uffcc\005\uffcc\010\uffcc\012\uffcc\014\uffcc\015\uffcc" +
    "\016\uffcc\017\uffcc\020\uffcc\022\uffcc\026\uffcc\036\uffcc\001" +
    "\002\000\006\006\220\007\217\001\002\000\004\025\231" +
    "\001\002\000\004\023\uffd3\001\002\000\004\023\037\001" +
    "\002\000\004\025\223\001\002\000\022\005\uffc4\010\uffc4" +
    "\014\uffc4\015\uffc4\016\uffc4\020\uffc4\022\uffc4\036\uffc4\001" +
    "\002\000\022\005\uffd4\010\uffd4\014\uffd4\015\uffd4\016\uffd4" +
    "\020\uffd4\022\uffd4\036\uffd4\001\002\000\022\005\020\010" +
    "\022\014\033\015\032\016\016\020\023\022\010\036\021" +
    "\001\002\000\024\005\020\010\022\014\033\015\032\016" +
    "\016\020\023\022\010\026\uffc3\036\021\001\002\000\004" +
    "\026\230\001\002\000\036\002\uffcf\005\uffcf\006\uffcf\007" +
    "\uffcf\010\uffcf\012\uffcf\014\uffcf\015\uffcf\016\uffcf\017\uffcf" +
    "\020\uffcf\022\uffcf\026\uffcf\036\uffcf\001\002\000\022\005" +
    "\uffc4\010\uffc4\014\uffc4\015\uffc4\016\uffc4\020\uffc4\022\uffc4" +
    "\036\uffc4\001\002\000\022\005\uffd3\010\uffd3\014\uffd3\015" +
    "\uffd3\016\uffd3\020\uffd3\022\uffd3\036\uffd3\001\002\000\022" +
    "\005\020\010\022\014\033\015\032\016\016\020\023\022" +
    "\010\036\021\001\002\000\024\005\020\010\022\014\033" +
    "\015\032\016\016\020\023\022\010\026\uffc3\036\021\001" +
    "\002\000\004\026\236\001\002\000\032\002\uffcd\005\uffcd" +
    "\010\uffcd\012\uffcd\014\uffcd\015\uffcd\016\uffcd\017\uffcd\020" +
    "\uffcd\022\uffcd\026\uffcd\036\uffcd\001\002\000\004\036\240" +
    "\001\002\000\004\023\241\001\002\000\006\024\uffbf\036" +
    "\244\001\002\000\006\024\uffc0\027\247\001\002\000\004" +
    "\024\uffc1\001\002\000\004\004\245\001\002\000\004\036" +
    "\246\001\002\000\006\024\uffbd\027\uffbd\001\002\000\004" +
    "\036\250\001\002\000\004\004\251\001\002\000\004\036" +
    "\252\001\002\000\006\024\uffbe\027\uffbe\001\002\000\032" +
    "\002\uffcb\005\uffcb\010\uffcb\012\uffcb\014\uffcb\015\uffcb\016" +
    "\uffcb\017\uffcb\020\uffcb\022\uffcb\026\uffcb\036\uffcb\001\002" +
    "\000\004\023\266\001\002\000\032\002\uffc7\005\uffc7\010" +
    "\uffc7\012\uffc7\014\uffc7\015\uffc7\016\uffc7\017\uffc7\020\uffc7" +
    "\022\uffc7\026\uffc7\036\uffc7\001\002\000\004\004\257\001" +
    "\002\000\022\005\uffc4\010\uffc4\014\uffc4\015\uffc4\016\uffc4" +
    "\020\uffc4\022\uffc4\036\uffc4\001\002\000\022\005\020\010" +
    "\022\014\033\015\032\016\016\020\023\022\010\036\021" +
    "\001\002\000\024\005\020\010\022\012\uffc3\014\033\015" +
    "\032\016\016\020\023\022\010\036\021\001\002\000\004" +
    "\012\263\001\002\000\004\030\264\001\002\000\004\026" +
    "\265\001\002\000\032\002\uffc8\005\uffc8\010\uffc8\012\uffc8" +
    "\014\uffc8\015\uffc8\016\uffc8\017\uffc8\020\uffc8\022\uffc8\026" +
    "\uffc8\036\uffc8\001\002\000\022\020\023\021\075\023\076" +
    "\035\064\036\066\037\uffe7\040\074\041\067\001\002\000" +
    "\004\024\270\001\002\000\004\004\271\001\002\000\022" +
    "\005\uffc4\010\uffc4\014\uffc4\015\uffc4\016\uffc4\020\uffc4\022" +
    "\uffc4\036\uffc4\001\002\000\022\005\020\010\022\014\033" +
    "\015\032\016\016\020\023\022\010\036\021\001\002\000" +
    "\024\005\020\010\022\012\uffc3\014\033\015\032\016\016" +
    "\020\023\022\010\036\021\001\002\000\004\012\275\001" +
    "\002\000\004\030\276\001\002\000\010\011\uffca\013\uffca" +
    "\026\uffca\001\002\000\022\020\023\021\075\023\076\035" +
    "\064\036\066\037\uffe7\040\074\041\067\001\002\000\004" +
    "\024\301\001\002\000\004\030\302\001\002\000\032\002" +
    "\uffde\005\uffde\010\uffde\012\uffde\014\uffde\015\uffde\016\uffde" +
    "\017\uffde\020\uffde\022\uffde\026\uffde\036\uffde\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\300\000\006\002\004\003\003\001\001\000\034\004" +
    "\025\005\016\017\030\022\012\023\013\033\014\036\023" +
    "\037\027\040\011\041\024\046\006\050\010\051\026\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\024\252\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\012\202\027" +
    "\035\001\001\000\004\034\130\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\032\005\045\017\030\022\012\023\013\033\014\036\023" +
    "\037\027\040\011\041\024\046\006\050\010\051\026\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\025\124\001\001\000\006\016\033\052\034\001" +
    "\001\000\006\012\037\027\035\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\030\051\031\054\032\052\001" +
    "\001\000\002\001\001\000\004\025\041\001\001\000\004" +
    "\013\042\001\001\000\034\004\043\005\016\017\030\022" +
    "\012\023\013\033\014\036\023\037\027\040\011\041\024" +
    "\046\006\050\010\051\026\001\001\000\034\005\045\017" +
    "\030\022\012\023\013\026\044\033\014\036\023\037\027" +
    "\040\011\041\024\046\006\050\010\051\026\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\006\070\011\064\027\071\035\067\046\072\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\030\056\031\054\032\052\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\031\061\032\052\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\007\101\010\100\011\076\030\051\031" +
    "\054\032\052\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\007\103\010" +
    "\100\011\076\030\056\031\054\032\052\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\010\106\011\076\001" +
    "\001\000\002\001\001\000\010\007\103\010\100\011\076" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\010" +
    "\113\011\076\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\006\070\011\064\027\071\035\121\046\072\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\033\126\001\001\000\004\027\141" +
    "\001\001\000\004\034\130\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\033\133\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\006\070\011" +
    "\064\027\071\035\137\046\072\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\036\143\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\006\070" +
    "\011\064\027\071\035\146\046\072\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\034\004\152" +
    "\005\016\017\030\022\012\023\013\033\014\036\023\037" +
    "\027\040\011\041\024\046\006\050\010\051\026\001\001" +
    "\000\034\005\045\017\030\022\012\023\013\026\153\033" +
    "\014\036\023\037\027\040\011\041\024\046\006\050\010" +
    "\051\026\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\025\157\001\001\000\036\004\160" +
    "\005\016\017\030\022\012\023\013\033\014\036\023\037" +
    "\027\040\011\041\024\044\161\046\006\050\010\051\026" +
    "\001\001\000\032\005\045\017\030\022\012\023\013\033" +
    "\014\036\023\037\027\040\011\041\024\046\006\050\010" +
    "\051\026\001\001\000\004\045\162\001\001\000\004\026" +
    "\166\001\001\000\014\006\070\011\064\027\071\035\164" +
    "\046\072\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\047\171\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\006\070\011\064\027\071\035\175\046\072\001\001" +
    "\000\002\001\001\000\014\006\070\011\064\027\071\035" +
    "\177\046\072\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\025\204\001" +
    "\001\000\004\013\205\001\001\000\034\004\206\005\016" +
    "\017\030\022\012\023\013\033\014\036\023\037\027\040" +
    "\011\041\024\046\006\050\010\051\026\001\001\000\034" +
    "\005\045\017\030\022\012\023\013\026\207\033\014\036" +
    "\023\037\027\040\011\041\024\046\006\050\010\051\026" +
    "\001\001\000\002\001\001\000\004\020\211\001\001\000" +
    "\012\014\214\015\215\021\212\052\213\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\014\220\001\001\000\006" +
    "\012\221\027\035\001\001\000\002\001\001\000\004\025" +
    "\223\001\001\000\004\013\224\001\001\000\034\004\225" +
    "\005\016\017\030\022\012\023\013\033\014\036\023\037" +
    "\027\040\011\041\024\046\006\050\010\051\026\001\001" +
    "\000\034\005\045\017\030\022\012\023\013\026\226\033" +
    "\014\036\023\037\027\040\011\041\024\046\006\050\010" +
    "\051\026\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\025\231\001\001\000\004\014\232\001\001\000\034" +
    "\004\233\005\016\017\030\022\012\023\013\033\014\036" +
    "\023\037\027\040\011\041\024\046\006\050\010\051\026" +
    "\001\001\000\034\005\045\017\030\022\012\023\013\026" +
    "\234\033\014\036\023\037\027\040\011\041\024\046\006" +
    "\050\010\051\026\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\042\242" +
    "\043\241\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\025\257\001\001\000\034\004" +
    "\260\005\016\017\030\022\012\023\013\033\014\036\023" +
    "\037\027\040\011\041\024\046\006\050\010\051\026\001" +
    "\001\000\034\005\045\017\030\022\012\023\013\026\261" +
    "\033\014\036\023\037\027\040\011\041\024\046\006\050" +
    "\010\051\026\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\006\070\011" +
    "\064\027\071\035\266\046\072\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\025\271\001\001\000\034\004" +
    "\272\005\016\017\030\022\012\023\013\033\014\036\023" +
    "\037\027\040\011\041\024\046\006\050\010\051\026\001" +
    "\001\000\034\005\045\017\030\022\012\023\013\026\273" +
    "\033\014\036\023\037\027\040\011\041\024\046\006\050" +
    "\010\051\026\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\006\070\011\064\027\071\035" +
    "\277\046\072\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    private ScannerLex scanner;
    private boolean hasToGenerateDigraph;
    private SymbolsTable symbolsTable;
    private Digraph digraph;
    //private ArrayList<Quadruple> quadruples;

    private Stack<String> stackTrueCond;
    private Stack<String> stackFalseCond;

    public Parser(ScannerLex scanner, SymbolFactory sf, boolean hasToGenerateDigraph) {
        super(scanner);
        this.scanner = scanner;
        this.hasToGenerateDigraph = hasToGenerateDigraph;
        this.symbolsTable = new SymbolsTable();
        this.digraph = new Digraph();
        //this.quadruples = new ArrayList<Quadruple>();
        this.stackTrueCond = new Stack<String>();
        this.stackFalseCond = new Stack<String>();
    }

    // In case of syntactic error
    public void report_fatal_error(String message, Object info) {
        String msgError = "Syntactic error";
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol symbol = ((java_cup.runtime.Symbol) info );

        if (symbol.left >= 0) {
            msgError += " in line "+(symbol.left+1);
            if (symbol.right>=0)
                msgError += ", column "+(symbol.right+1);
            }
        }

        msgError += ". Error message: " + message;
        System.err.println(msgError);

        try {
            throw new MalformedStructureException(
                 CompilerException.CompilerErrorType.syntactic,
                 msgError
            );
         } catch (MalformedStructureException ex) {
             System.err.println("ERROR: " + ex.getMessage());
         }

        report_error(message, info);
        System.exit(1);
    }

    private void initializeTypeInt() {
        String keywordType = "int";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer,
            4, // bytes
            Integer.MIN_VALUE,
            Integer.MAX_VALUE
        );

        this.symbolsTable.add(keywordType, typeDescription);
    }

    private void initializeTypeBoolean() {
        String keywordType = "boolean";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean,
            1, // bytes
            0,
            1
            );

        this.symbolsTable.add(keywordType, typeDescription);
        
    }

    private void initializeTypeString() {
        String keywordType = "string";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_string,
            0, // bytes
            0,
            0
            );

        this.symbolsTable.add(keywordType, typeDescription);
    }

    private void initializeTypeNone() {
        String keywordType = "none";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_none,
            0, // bytes
            0,
            0
            );

        this.symbolsTable.add(keywordType, typeDescription);
    }



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= ROOT EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolRoot start_val = (SymbolRoot)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // ROOT ::= INIT_TYPES INSTRS 
            {
              SymbolRoot RESULT =null;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[ROOT => INIT_TYPES INSTRS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INIT_TYPES);
                childs.add(NodeGraph.VARIABLES.INSTRS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.ROOT);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                // ============== GENERATE DIGRAPH FILE ==============
                if (hasToGenerateDigraph) {
                    digraph.generateDotFile();
                }
                // ===================================================

                symbolsTable.closeFile(); 
                /*
                System.out.println("QUADRUPLES: ");
                for (int i = 0; i < quadruples.size(); i++) {
                    System.out.println(quadruples.get(i));
                }

                System.out.println("\nVARIABLE'S TABLE:");
                variablesTable.showInfo();
                */


                boolean hasFinished = true;
                RESULT = new SymbolRoot(hasFinished);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ROOT",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // INIT_TYPES ::= 
            {
              SymbolInitType RESULT =null;
		  
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description = "[INIT_TYPES => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INIT_TYPES);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    initializeTypeInt();
                    initializeTypeBoolean();
                    initializeTypeString();
                    initializeTypeNone(); 
                    RESULT = new SymbolInitType();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_TYPES",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // INSTRS ::= INSTRS INSTR 
            {
              SymbolInstrs RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTRS => INSTRS INSTR]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.INSTR);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTRS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstrs();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTRS",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // INSTRS ::= INSTR 
            {
              SymbolInstrs RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTRS => INSTR]";
                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INSTR);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTRS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstrs();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTRS",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // INSTR ::= DECLS 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => DECLS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.DECLS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // INSTR ::= COND_IF 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => COND_IF]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.COND_IF);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // INSTR ::= SWITCH 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => SWITCH]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.SWITCH);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // INSTR ::= WHILE 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => WHILE]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.WHILE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // INSTR ::= FOR 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => FOR]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.FOR);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // INSTR ::= ASSIGN 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => ASSIGN]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.ASSIGN);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // INSTR ::= OUTPUT 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => OUTPUT]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.OUTPUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // INSTR ::= FUNCTION 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => FUNCTION]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.FUNCTION);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // INSTR ::= CALL 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => CALL]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.CALL);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // DECLS ::= id separator DECLS 
            {
              SymbolDecls RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int declsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int declsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolDecls decls = (SymbolDecls)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[DECLS => id separator DECLS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.DECLS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.DECLS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolDecls symbolDecls = decls;

                TypeDescription typeDescription = symbolDecls.typeDescription;

                symbolsTable.add(id_variable, typeDescription);

                // ================ INTERMEDIATE CODE ======================
                //variablesTable.addVariable(id_variable);
                //Quadruple quadruple = new Quadruple(OP_CODE.assignRef, decls.idVariable, "", id_variable);
                //quadruples.add(quadruple);
                //symbolDecls.idVariable = id_variable;
                // =========================================================

                RESULT = symbolDecls;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLS",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // DECLS ::= id CONSTANT two_points id op_assign VALUE final_sentence 
            {
              SymbolDecls RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int symbol_constantleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int symbol_constantright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		SymbolConstant symbol_constant = (SymbolConstant)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int symbol_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int symbol_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue symbol_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[DECLS => id CONSTANT two_points id op_assign VALUE final_sentence ]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.CONSTANT);
                childs.add(NodeGraph.VARIABLES.VALUE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.DECLS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                // ================ CHECK IF TYPE IS CORRECT ===========================
                TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                    throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. You content description must be '" + TypeDescription.CONTENT_DESCRIPTION.dtype + "' but it's '" + typeDescription.contentDescription + "'"
                        );
                }

                if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                            || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                            || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                        )
                    ) { 
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. Type of variable must have a correct subjacent type. Your basic subjacent type is '" + typeDescription.basicSubjacentType + "'"
                        ); 
                }
                // =====================================================================
                
                // ================ COMPARE TYPE AND VALUE OF VARIABLE ==================
                SymbolValue    symbolValue = symbol_value;
                SymbolConstant symbolConstant = symbol_constant;

                boolean isConstant = false;

                if (symbolConstant != null) {
                    isConstant = symbolConstant.isConstant;
                }

                if (isConstant && !symbolValue.isConstant) {
                    throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. Value of variable isn't a constant."
                        );
                }

                if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                    if (symbolValue.basicSubjacentType != typeDescription.basicSubjacentType){
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. Type of variable and it's value must have the same subjacent type."
                            + " Subjacent type of type: " + typeDescription.basicSubjacentType + ". "
                            + "Subjacent type of value: " + symbolValue.basicSubjacentType + "."
                            ); 
                    }

                } else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dfunc
                    ) {

                    if (!type_variable.equals(symbolValue.nameType)) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. The type of variable and his value must be the same."
                            + "Type of variable: " + type_variable + ". "
                            + "Type of value: " + symbolValue.nameType + "."
                            );
                    }
                }

                TypeDescription typeDescriptionForNewVariables;

                if (isConstant && symbolValue.isConstant) {
                    typeDescriptionForNewVariables = new TypeDescription(
                    CONTENT_DESCRIPTION.dconst,
                    type_variable,
                    symbolValue.valueType
                    );

                } else {
                    typeDescriptionForNewVariables = new TypeDescription(
                    CONTENT_DESCRIPTION.dvar,
                    type_variable
                    );
                }

                symbolsTable.add(id_variable, typeDescriptionForNewVariables);
                SymbolDecls symbolDecls = new SymbolDecls(typeDescriptionForNewVariables);
                // ================ INTERMEDIATE CODE ======================
                //variablesTable.addVariable(id_variable);
                //Quadruple quadruple = new Quadruple(OP_CODE.assignRef, symbol_value.idVariable, "", id_variable);
                //quadruples.add(quadruple);

                //symbolDecls.idVariable = symbolValue.idVariable;
                // =======================================================

                RESULT = symbolDecls;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLS",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // CONSTANT ::= constant 
            {
              SymbolConstant RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description = "[CONSTANT => constant]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CONSTANT);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    boolean isConstant = true;
                    RESULT = new SymbolConstant(isConstant);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONSTANT",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // CONSTANT ::= 
            {
              SymbolConstant RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description = "[CONSTANT => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CONSTANT);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    boolean isConstant = false;
                    RESULT = new SymbolConstant(isConstant);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONSTANT",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ASSIGN ::= id op_assign VALUE final_sentence 
            {
              SymbolAssign RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int symbol_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int symbol_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue symbol_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                        // ============== GENERATE NODE FOR DIGRAPH ==============
                                        String description = "[ASSIGN => id op_assign VALUE final_sentence]";

                                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                                        childs.add(NodeGraph.VARIABLES.VALUE);

                                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.ASSIGN);
                                        digraph.addNode(nodeGraph, childs);
                                        // =======================================================

                                       // ================ COMPARE TYPE AND VALUE OF VARIABLE ==================
                                        TypeDescription variableTypeDescription = symbolsTable.query(id_variable);
                                        SymbolValue symbolValue = symbol_value;

                                        if (variableTypeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {
                                            throw new IncorrectTypeException(
                                                CompilerException.CompilerErrorType.semantic,
                                                "Operation assignment. We can't assign a value to a constant"
                                            ); 
                                        }

                                        if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                                            TypeDescription typeDescriptionParent = symbolsTable.query(variableTypeDescription.nameType);

                                            if (symbolValue.basicSubjacentType != typeDescriptionParent.basicSubjacentType){
                                                throw new IncorrectTypeException(
                                                    CompilerException.CompilerErrorType.semantic,
                                                    "Operation assignment. Type of variable and it's value must have the same subjacent type."
                                                    + " Subjacent type of type: " + typeDescriptionParent.basicSubjacentType + ". "
                                                    + "Subjacent type of value: " + symbolValue.basicSubjacentType + "."
                                                    ); 
                                            }

                                        }else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dfunc
                                                ) {

                                            if (!variableTypeDescription.nameType.equals(symbolValue.nameType)) {
                                                throw new IncorrectTypeException(
                                                    CompilerException.CompilerErrorType.semantic,
                                                    "Operation assignment. The type of variable and his value must be the same."
                                                    + "Type of variable: " + variableTypeDescription.nameType + ". "
                                                    + "Type of value: " + symbolValue.nameType + "."
                                                    );
                                            }
                                        } else {
                                            throw new IncorrectTypeException(
                                                    CompilerException.CompilerErrorType.semantic,
                                                    "The value has an incorrect type: " + symbolValue.contentDescription + "."
                                            );
                                        }

                                        // =====================================================================

                                        //Quadruple quadruple = new Quadruple(OP_CODE.assignRef, symbolValue.idVariable, "", id_variable);
                                        //quadruples.add(quadruple);

                                        RESULT = new SymbolAssign();
                                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGN",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // INIT_OP_ARITH ::= lparen OP_ARITHMETIC rparen 
            {
              SymbolInitOpArith RESULT =null;
		int op_arithleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_arithright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpArithmetic op_arith = (SymbolOpArithmetic)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[INIT_OP_ARITH => lparen OP_ARITHMETIC rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITHMETIC);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INIT_OP_ARITH);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithmetic symbolOpArithmetic = op_arith;
                        SymbolInitOpArith symbolInitOpArith = new SymbolInitOpArith();

                        symbolInitOpArith.isConstant = symbolOpArithmetic.isConstant;

                        if (symbolOpArithmetic.isConstant) {
                            symbolInitOpArith.valueType = symbolOpArithmetic.valueType;
                        }

                        symbolInitOpArith.idVariable = symbolOpArithmetic.idVariable;
                        RESULT = symbolInitOpArith;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_OP_ARITH",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // OP_ARITHMETIC ::= OP_ARITHMETIC op_arithmetic OP_ARITH_VALUE 
            {
              SymbolOpArithmetic RESULT =null;
		int op_arithmetic_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_arithmetic_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolOpArithmetic op_arithmetic_val = (SymbolOpArithmetic)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int op_arithmeticleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_arithmeticright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String op_arithmetic = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int op_arith_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_arith_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpArithValue op_arith_value = (SymbolOpArithValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITHMETIC => OP_ARITHMETIC op_arithmetic OP_ARITH_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITHMETIC);
                        childs.add(NodeGraph.VARIABLES.OP_ARITH_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITHMETIC);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithmetic symbolOpArithmeticVal = op_arithmetic_val;
                        SymbolOpArithValue symbolOpArithValue = op_arith_value;

                        SymbolOpArithmetic symbolOpArithmetic = new SymbolOpArithmetic();

                        OpCode opCode = OpCode.sum;
                        switch(op_arithmetic) {
                            case "+": 
                                    opCode = OpCode.sum;
                                    break;
                            case "-": 
                                    opCode = OpCode.sub;
                                    break;
                            case "*": 
                                    opCode = OpCode.mult;
                                    break;
                            case "/": 
                                    opCode = OpCode.div;
                                    break;
                            case "%":  
                                    opCode = OpCode.mod;
                                    break;
                        }
                        // We can calculate the value if all operands are constant
                        if (symbolOpArithmetic.isConstant && symbolOpArithValue.isConstant) {
                            symbolOpArithmetic.isConstant = true;

                            Integer newValue = -1;
                            Integer value1 = (Integer) symbolOpArithmeticVal.valueType;
                            Integer value2 = (Integer) symbolOpArithValue.valueType;

                            switch(op_arithmetic) {
                                case "+": newValue = value1 + value2; 
                                        break;
                                case "-": newValue = value1 - value2; 
                                        break;
                                case "*": newValue = value1 * value2;
                                        break;
                                case "/": newValue = value1 / value2;
                                        break;
                                case "%": newValue = value1 % value2; 
                                        break;
                            }

                            symbolOpArithmetic.valueType = newValue;

                        }
                        /*
                        String uuidVariable = variablesTable.generateVariable();

                        Quadruple quadruple = new Quadruple(opCode, symbolOpArithmeticVal.idVariable, symbolOpArithValue.idVariable, uuidVariable);
                        quadruples.add(quadruple);

                        symbolOpArithmetic.idVariable = uuidVariable;
                        */
                        RESULT = symbolOpArithmetic;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITHMETIC",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // OP_ARITHMETIC ::= OP_ARITH_VALUE op_arithmetic OP_ARITH_VALUE 
            {
              SymbolOpArithmetic RESULT =null;
		int op_arith_value1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_arith_value1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolOpArithValue op_arith_value1 = (SymbolOpArithValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int op_arithmeticleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_arithmeticright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String op_arithmetic = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int op_arith_value2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_arith_value2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpArithValue op_arith_value2 = (SymbolOpArithValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITHMETIC => OP_ARITH_VALUE op_arithmetic OP_ARITH_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        childs.add(NodeGraph.VARIABLES.OP_ARITH_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITHMETIC);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithValue symbolOpArithValue1 = op_arith_value1;
                        SymbolOpArithValue symbolOpArithValue2 = op_arith_value2;

                        SymbolOpArithmetic symbolOpArithmetic = new SymbolOpArithmetic();

                        OpCode opCode = OpCode.sum;
                        switch(op_arithmetic) {
                                case "+":
                                        opCode = OpCode.sum;
                                        break;
                                case "-":
                                        opCode = OpCode.sub;
                                        break;
                                case "*":
                                        opCode = OpCode.mult;
                                        break;
                                case "/":
                                        opCode = OpCode.div;
                                        break;
                                case "%": 
                                        opCode = OpCode.mod;
                                        break;

                            }
                        // We can calculate the value if all operands are constant
                        if (symbolOpArithValue1.isConstant && symbolOpArithValue2.isConstant) {
                            symbolOpArithmetic.isConstant = true;

                            Integer newValue = -1;
                            Integer value1 = (Integer) symbolOpArithValue1.valueType;
                            Integer value2 = (Integer) symbolOpArithValue2.valueType;

                            switch(op_arithmetic) {
                                case "+": newValue = value1 + value2;
                                        break;
                                case "-": newValue = value1 - value2;
                                        break;
                                case "*": newValue = value1 * value2;
                                        break;
                                case "/": newValue = value1 / value2;
                                        break;
                                case "%": newValue = value1 % value2;
                                        break;

                            }
                            symbolOpArithmetic.valueType = newValue;
                        }
                        /*
                        String uuidVariable = variablesTable.generateVariable();

                        Quadruple quadruple = new Quadruple(opCode, symbolOpArithValue1.idVariable, symbolOpArithValue2.idVariable, uuidVariable);
                        quadruples.add(quadruple);

                        symbolOpArithmetic.idVariable = uuidVariable;
                        */
                        RESULT = symbolOpArithmetic; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITHMETIC",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // OP_ARITH_VALUE ::= lparen OP_ARITHMETIC rparen 
            {
              SymbolOpArithValue RESULT =null;
		int op_aritleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_aritright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpArithmetic op_arit = (SymbolOpArithmetic)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITH_VALUE => lparen OP_ARITHMETIC rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITHMETIC);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithmetic symbolOpArithmetic = op_arit;
                        SymbolOpArithValue symbolOpArithValue = new SymbolOpArithValue();
                        symbolOpArithValue.isConstant = symbolOpArithmetic.isConstant;

                        if (symbolOpArithmetic.isConstant) {
                            symbolOpArithValue.valueType = symbolOpArithmetic.valueType;
                        }

                        symbolOpArithValue.idVariable = symbolOpArithmetic.idVariable;
                        RESULT = symbolOpArithValue; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITH_VALUE",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // OP_ARITH_VALUE ::= SIGN number 
            {
              SymbolOpArithValue RESULT =null;
		int signleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int signright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolSign sign = (SymbolSign)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int number_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int number_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String number_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITH_VALUE => SIGN number]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.SIGN);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================

                        Integer number = new Integer(number_val);
                        SymbolSign symbolSign = sign;
                        if (symbolSign != null && symbolSign.isNegative) {
                            number = -number;
                        }

                        SymbolOpArithValue symbolOpArithValue = new SymbolOpArithValue(number);
                        /*
                        String uuidVariable = variablesTable.generateVariable();

                        Quadruple quadruple = new Quadruple(OP_CODE.assignVal, String.valueOf(number_val), "", uuidVariable);
                        quadruples.add(quadruple);

                        symbolOpArithValue.idVariable = uuidVariable;
                        */
                        RESULT = symbolOpArithValue;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITH_VALUE",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // OP_ARITH_VALUE ::= id 
            {
              SymbolOpArithValue RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITH_VALUE => id]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        TypeDescription typeDescription = symbolsTable.query(id);
                        if (typeDescription.contentDescription != CONTENT_DESCRIPTION.dvar 
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.dconst
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.darg) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Arithmetic operation with id '" + id + "'. The value has an incorrect content description: " + typeDescription.contentDescription + "."
                                );
                        }
                        TypeDescription typeDescriptionType = symbolsTable.query(typeDescription.nameType);
                        if (typeDescriptionType.basicSubjacentType != BASIC_SUBJACENT_TYPE.ts_integer) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Arithmetic operation with id '" + id + "'. The value has an incorrect subjacent type: " + typeDescriptionType.basicSubjacentType + "."
                            );
                        }

                        SymbolOpArithValue symbolOpArithValue = new SymbolOpArithValue();

                        // We pass the value to the node above when it's a constant
                        if (typeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {
                            Integer number = (Integer) typeDescription.value;

                            symbolOpArithValue.isConstant = true;
                            symbolOpArithValue.valueType = number;
                        }  

                        symbolOpArithValue.idVariable = id;
                        
                        RESULT = symbolOpArithValue; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITH_VALUE",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // SIGN ::= op_arithmetic 
            {
              SymbolSign RESULT =null;
		int op_aritleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_aritright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String op_arit = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[SIGN => op_arithmetic]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SIGN);
                digraph.addNode(nodeGraph);
                // =======================================================

                boolean isNegative = false;

                if (!(op_arit.equals("+") || op_arit.equals("-"))) {
                   throw new IncorrectOperatorException(
                        CompilerException.CompilerErrorType.semantic,
                        "Sign must be '+' or '-'."
                    ); 
                }

                if (op_arit.equals("-")) {
                    isNegative = true;
                }

                RESULT = new SymbolSign(isNegative); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGN",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // SIGN ::= 
            {
              SymbolSign RESULT =null;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[SIGN => lambda]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SIGN);
                digraph.addNode(nodeGraph);
                // =======================================================

                RESULT = new SymbolSign(); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGN",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VALUE ::= INIT_OP_ARITH 
            {
              SymbolValue RESULT =null;
		int init_op_arithleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int init_op_arithright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolInitOpArith init_op_arith = (SymbolInitOpArith)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => INIT_OP_ARITH]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.INIT_OP_ARITH);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    SymbolInitOpArith symbolInitOpArith = init_op_arith;
                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_integer);

                    symbolValue.isConstant = symbolInitOpArith.isConstant;
                    // If it is a constant, then we pass the value to the higher node
                    if (symbolInitOpArith.isConstant) {
                        symbolValue.valueType = symbolInitOpArith.valueType;
                    }

                    symbolValue.idVariable = symbolInitOpArith.idVariable;
                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VALUE ::= INIT_OP_BOOL 
            {
              SymbolValue RESULT =null;
		int init_op_boolleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int init_op_boolright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolInitOpBool init_op_bool = (SymbolInitOpBool)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => INIT_OP_BOOL]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    SymbolInitOpBool symbolInitOpBool = init_op_bool;
                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_boolean);

                    // If it is a constant, then we pass the value to the higher node
                    if (symbolInitOpBool.isConstant) {
                        symbolValue.isConstant = true;
                        symbolValue.valueType = symbolInitOpBool.valueType;
                    }
                    symbolValue.idVariable = symbolInitOpBool.idVariable;
                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VALUE ::= SIGN number 
            {
              SymbolValue RESULT =null;
		int signleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int signright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolSign sign = (SymbolSign)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int number_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int number_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String number_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => SIGN number]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.SIGN);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    Integer value = new Integer(number_value);
                    SymbolSign symbolSign = sign;

                    if (symbolSign != null) {
                        value = (symbolSign.hasSign && symbolSign.isNegative) ? -value : value;
                    }
                    /*
                    String uuidVariable = variablesTable.generateVariable();

                    Quadruple quadruple = new Quadruple(OP_CODE.assignVal, String.valueOf(value), "", uuidVariable);
                    quadruples.add(quadruple);
                    */
                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_integer, value);
                    //symbolValue.idVariable = uuidVariable;

                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // VALUE ::= text 
            {
              SymbolValue RESULT =null;
		int text_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int text_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String text_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => text]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    String value = new String(text_value.replace("\"", "")); // Delete double quote from lexeme
                    /*
                    String uuidVariable = variablesTable.generateVariable();
                    Quadruple quadruple = new Quadruple(OP_CODE.assignVal, value, "", uuidVariable);
                    quadruples.add(quadruple);
                    */

                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_string, value);
                    //symbolValue.idVariable = uuidVariable;
                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // VALUE ::= bool 
            {
              SymbolValue RESULT =null;
		int bool_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bool_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String bool_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => bool]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    Boolean value = new Boolean(bool_value);
                    /*
                    String uuidVariable = variablesTable.generateVariable();
                    Quadruple quadruple = new Quadruple(OP_CODE.assignVal, Boolean.toString(value) , "", uuidVariable);
                    quadruples.add(quadruple);
                    */
                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_boolean, value);
                    //symbolValue.idVariable = uuidVariable;
                    RESULT = symbolValue;  
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // VALUE ::= inst_input lparen id rparen 
            {
              SymbolValue RESULT =null;
		int type_idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int type_idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String type_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => inst_input lparen rparen]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    TypeDescription typeDescription = symbolsTable.query(type_id);

                    if (typeDescription.contentDescription != CONTENT_DESCRIPTION.dtype) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in instruction 'input'. The content in parameters isn't a type."
                        );
                    }

                    if (typeDescription.basicSubjacentType == BASIC_SUBJACENT_TYPE.ts_none) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in instruction 'input'. Incorrect basic subjacent type."
                        );
                    }

                    RESULT = new SymbolValue(typeDescription.basicSubjacentType);  

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // VALUE ::= id 
            {
              SymbolValue RESULT =null;
		int id_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int id_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => id]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    TypeDescription typeDescription = symbolsTable.query(id_value);

                    SymbolValue symbolValue = new SymbolValue(
                        typeDescription.contentDescription,
                        typeDescription.nameType
                    );

                    // If it is a constant, then we pass the value to the higher node
                    if (typeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {   
                        symbolValue.isConstant = true;
                        symbolValue.valueType = typeDescription.value;
                    }

                    symbolValue.idVariable = id_value;

                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // VALUE ::= CALL 
            {
              SymbolValue RESULT =null;
		int callleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int callright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolCall call = (SymbolCall)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => CALL]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CALL);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    SymbolCall symbolCall = call;

                    TypeDescription typeDescription = symbolsTable.query(symbolCall.idFunction);

                    RESULT = new SymbolValue(CONTENT_DESCRIPTION.dfunc, typeDescription.nameType);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // OUTPUT ::= inst_output lparen VALUE rparen final_sentence 
            {
              SymbolOutput RESULT =null;
		int symbol_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int symbol_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolValue symbol_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		

                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[OUTPUT => inst_output lparen VALUE rparen final_sentence]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.VALUE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OUTPUT);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolValue symbolValue = symbol_value;
                BASIC_SUBJACENT_TYPE subjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                // ======================= GET SUBJACENT TYPE OF OUR VALUE ==========================
                if (!(symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull
                            ||symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                            || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                            || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                            || symbolValue.contentDescription == CONTENT_DESCRIPTION.dfunc
                        )) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in output operation. The value has an incorrect type: " + symbolValue.contentDescription + "."
                        );
                    
                }
                // ====================================================================================

                //Quadruple quadruple = new Quadruple(OP_CODE.output, "", "", symbolValue.idVariable);
                //quadruples.add(quadruple);

                RESULT = new SymbolOutput();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OUTPUT",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // INIT_OP_BOOL ::= lparen OP_BOOLEAN rparen 
            {
              SymbolInitOpBool RESULT =null;
		int op_booleanleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_booleanright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpBoolean op_boolean = (SymbolOpBoolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[INIT_OP_BOOL => lparen OP_BOOLEAN rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOLEAN);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INIT_OP_BOOL);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolean symbolOpBoolean = op_boolean;
                        SymbolInitOpBool symbolInitOpBool = new SymbolInitOpBool();

                        // If it is a constant, then we pass the value to the higher node
                        if (symbolOpBoolean.isConstant) {
                            symbolInitOpBool.isConstant = true;
                            symbolInitOpBool.valueType = symbolOpBoolean.valueType;
                        }
                        /*
                        if (!symbolOpBoolean.isSingleBoolean) {
                            Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", symbolOpBoolean.idLabel);
                            quadruples.add(quadruple);
                        }
                        */
                        
                        symbolInitOpBool.idVariable = symbolOpBoolean.idVariable;

                        RESULT = symbolInitOpBool;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_OP_BOOL",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // OP_BOOLEAN ::= OP_BOOLEAN op_logic OP_BOOL_VALUE 
            {
              SymbolOpBoolean RESULT =null;
		int op_boolean_val1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_boolean_val1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolOpBoolean op_boolean_val1 = (SymbolOpBoolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int op_logicleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_logicright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String op_logic = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int op_boolean_val2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_boolean_val2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpBoolValue op_boolean_val2 = (SymbolOpBoolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOLEAN => OP_BOOLEAN op_logic OP_BOOL_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOLEAN);
                        childs.add(NodeGraph.VARIABLES.OP_BOOL_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOLEAN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolean symbolOpBooleanVal1 = op_boolean_val1;
                        SymbolOpBoolValue symbolOpBoolVal2 = op_boolean_val2;
                        SymbolOpBoolean symbolOpBoolean = new SymbolOpBoolean();

                        // If it is a constant, then we calculate the value and pass it to the higher node
                        if (symbolOpBooleanVal1.isConstant && symbolOpBoolVal2.isConstant) {
                            Boolean val1 = (Boolean) symbolOpBooleanVal1.valueType;
                            Boolean val2 = (Boolean) symbolOpBoolVal2.valueType;

                            Boolean newValue = false;

                            switch(op_logic) {
                                case "&&": 
                                    newValue = val1 && val2;
                                break;
                                case "||": 
                                    newValue = val1 || val2;
                                break;
                            }

                            symbolOpBoolean.isConstant = true;
                            symbolOpBoolean.valueType = newValue;

                        }

                        OpCode opCodeVariable = OpCode.and;
                        OpCode opCodeConditional = OpCode.condTrue;

                        switch(op_logic) {
                            case "&&": 
                                opCodeVariable = OpCode.and;
                                opCodeConditional = OpCode.condFalse;
                            break;
                            case "||":
                                opCodeVariable = OpCode.or;
                                opCodeConditional = OpCode.condTrue;
                            break;
                        }
                        /*
                        Quadruple quadruple = new Quadruple(opCodeConditional, symbolOpBooleanVal1.idVariable, "" , symbolOpBooleanVal1.idLabel);
                        quadruples.add(symbolOpBooleanVal1.indexQuadruples, quadruple);

                        Quadruple quadruple2 = new Quadruple(opCodeVariable, symbolOpBoolVal2.idVariable, "" , symbolOpBooleanVal1.idVariable);
                        quadruples.add(quadruple2);

                        symbolOpBoolean.idLabel = symbolOpBooleanVal1.idLabel;
                        symbolOpBoolean.idVariable = symbolOpBooleanVal1.idVariable;
                        symbolOpBoolean.indexQuadruples = quadruples.size();
                        symbolOpBoolean.isSingleBoolean = false;
                        */
                        RESULT = symbolOpBoolean;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOLEAN",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // OP_BOOLEAN ::= OP_BOOL_VALUE 
            {
              SymbolOpBoolean RESULT =null;
		int op_bool_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_bool_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpBoolValue op_bool_value = (SymbolOpBoolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOLEAN => OP_BOOL_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOL_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOLEAN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolValue symbolOpBoolValue =  op_bool_value;
                        SymbolOpBoolean symbolOpBoolean = new SymbolOpBoolean();

                        // If it is a constant, then we pass the value to the higher node
                        if (symbolOpBoolValue.isConstant) {
                            symbolOpBoolean.isConstant = true;
                            symbolOpBoolean.valueType = symbolOpBoolValue.valueType;
                        }
                        /*
                        String uuidLabel = UUID.randomUUID().toString();

                        symbolOpBoolean.idVariable = symbolOpBoolValue.idVariable;
                        symbolOpBoolean.idLabel = uuidLabel;
                        symbolOpBoolean.indexQuadruples = quadruples.size();
                        symbolOpBoolean.isSingleBoolean = true;
                        */
                        RESULT = symbolOpBoolean;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOLEAN",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // OP_BOOL_VALUE ::= bool 
            {
              SymbolOpBoolValue RESULT =null;
		int bool_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bool_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String bool_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => bool]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph);
                        // =======================================================
                        Boolean boolVal = new Boolean(bool_val);
                         
                        SymbolOpBoolValue symbolOpBoolValue = new SymbolOpBoolValue(boolVal);
                        /*
                        String uuidVariable = variablesTable.generateVariable();

                        Quadruple quadruple = new Quadruple(OP_CODE.assignVal, Boolean.toString(boolVal), "", uuidVariable);
                        quadruples.add(quadruple);

                        symbolOpBoolValue.idVariable = uuidVariable;
                        */
                        RESULT = symbolOpBoolValue;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // OP_BOOL_VALUE ::= lparen OP_BOOLEAN rparen 
            {
              SymbolOpBoolValue RESULT =null;
		int op_booleanleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_booleanright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpBoolean op_boolean = (SymbolOpBoolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => lparen OP_BOOLEAN rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOLEAN);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolean symbolOpBoolean = op_boolean;
                        SymbolOpBoolValue symbolOpBoolValue = new SymbolOpBoolValue();

                        // If it is a constant, then we pass the value to the higher node
                        if(symbolOpBoolean.isConstant) {
                            symbolOpBoolValue.isConstant = true;
                            symbolOpBoolValue.valueType = symbolOpBoolean.valueType;
                        }
                        /*
                        Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", symbolOpBoolean.idLabel);
                        quadruples.add(quadruple);

                        symbolOpBoolValue.idVariable = symbolOpBoolean.idVariable;
                        */
                        RESULT = symbolOpBoolValue;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // OP_BOOL_VALUE ::= id 
            {
              SymbolOpBoolValue RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => id]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        TypeDescription typeDescription = symbolsTable.query(id);
                        if (typeDescription.contentDescription != CONTENT_DESCRIPTION.dvar 
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.dconst 
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.darg) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in boolean operation. The value has an incorrect content description: " + typeDescription.contentDescription + "."
                                );
                        }
                        TypeDescription typeDescriptionType = symbolsTable.query(typeDescription.nameType);
                        if (typeDescriptionType.basicSubjacentType != BASIC_SUBJACENT_TYPE.ts_boolean) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in boolean operation. The value has an incorrect subjacent type: " + typeDescriptionType.basicSubjacentType + "."
                            );
                        }

                        SymbolOpBoolValue symbolOpBoolValue = new SymbolOpBoolValue();
                        // If it is a constant, then we pass the value to the higher node
                        if (typeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {
                            symbolOpBoolValue.isConstant = true;
                            symbolOpBoolValue.valueType = typeDescription.value;
                        }

                        symbolOpBoolValue.idVariable = id;

                        RESULT = symbolOpBoolValue; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // OP_BOOL_VALUE ::= RELATIONAL_COMP 
            {
              SymbolOpBoolValue RESULT =null;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => RELATIONAL_COMP]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.RELATIONAL_COMP);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================

                        RESULT = new SymbolOpBoolValue(); 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // RELATIONAL_COMP ::= lbracket VALUE op_relational VALUE rbracket 
            {
              SymbolRelationalComp RESULT =null;
		int value_1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int value_1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		SymbolValue value_1 = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int op_relationalleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_relationalright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String op_relational = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int value_2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int value_2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue value_2 = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[RELATIONAL_COMP => lbracket VALUE op_relational VALUE rbracket]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.VALUE);
                        childs.add(NodeGraph.VARIABLES.VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.RELATIONAL_COMP);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================

                        SymbolValue symbolValue1 = value_1;
                        SymbolValue symbolValue2 = value_2;

                        BASIC_SUBJACENT_TYPE value1SubjacenBasicType = BASIC_SUBJACENT_TYPE.ts_none;
                        BASIC_SUBJACENT_TYPE value2SubjacenBasicType = BASIC_SUBJACENT_TYPE.ts_none;

                        // ===================== CHECK VALUE 1 AND GET HIS SUUBJACENT BASIC TYPE ========================
                        if (symbolValue1.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            value1SubjacenBasicType = symbolValue1.basicSubjacentType;
                            
                        } else if (symbolValue1.contentDescription == CONTENT_DESCRIPTION.dvar
                                || symbolValue1.contentDescription == CONTENT_DESCRIPTION.dconst
                                || symbolValue1.contentDescription == CONTENT_DESCRIPTION.darg
                                || symbolValue1.contentDescription == CONTENT_DESCRIPTION.dfunc
                            ) {
                            TypeDescription typeDescription1 = symbolsTable.query(symbolValue1.nameType);
                            value1SubjacenBasicType = typeDescription1.basicSubjacentType;

                            if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_none) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The basic subjacent type can't be 'none'."
                                );
                            }

                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The value has an incorrect content description: " + symbolValue1.contentDescription + "."
                                );
                        }
                        // =============================================================================================
                        
                        // ===================== CHECK VALUE 2 AND GET HIS SUUBJACENT BASIC TYPE ========================
                        if (symbolValue2.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            value2SubjacenBasicType = symbolValue2.basicSubjacentType;
                            
                        } else if (symbolValue2.contentDescription == CONTENT_DESCRIPTION.dvar
                                || symbolValue2.contentDescription == CONTENT_DESCRIPTION.dconst
                                || symbolValue2.contentDescription == CONTENT_DESCRIPTION.darg
                                || symbolValue2.contentDescription == CONTENT_DESCRIPTION.dfunc
                            ) {
                            TypeDescription typeDescription2 = symbolsTable.query(symbolValue2.nameType);
                            value2SubjacenBasicType = typeDescription2.basicSubjacentType;

                            if (value2SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_none) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The basic subjacent type can't be 'none'."
                                );
                            }

                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The value has an incorrect content description: " + symbolValue2.contentDescription + "."
                            );
                        }
                        // =============================================================================================

                        // ====================== CHECK SUBJACENT BASIC TYPES FROM VALUES ==============================
                        if (value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_integer
                            && value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_boolean
                            && value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_string
                            ) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. One value has an incorrect subjacent basic type: " + value1SubjacenBasicType + "."
                            );
                        }

                        if (value2SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_integer
                            && value2SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_boolean
                            && value2SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_string
                            ) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. One value has an incorrect subjacent basic type: " + value2SubjacenBasicType + "."
                            );
                        }

                        if (value1SubjacenBasicType != value2SubjacenBasicType) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The values has differente subjacent basic types. " 
                                    + "Value 1 has " + value1SubjacenBasicType + " as his subjacent basic type. "
                                    + "Value 1 has " + value2SubjacenBasicType + " as his subjacent basic type. "
                            );
                        }
                        // =============================================================================================

                        if ((op_relational.equals("<")
                            || op_relational.equals("<=")
                            || op_relational.equals(">")
                            || op_relational.equals(">="))
                            && value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_integer
                            ) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. This relational operator '"
                                    + op_relational 
                                    +"' only compares numbers, not values with this basic subjacent type " 
                                    + value1SubjacenBasicType 
                                    + "."
                            );
                        }

                        SymbolRelationalComp symbolRelationalComp = new SymbolRelationalComp();
                        
                        // If it is a constant, then we pass the value to the higher node
                        if (symbolValue1.isConstant && symbolValue2.isConstant) {
                            Boolean newValue = false;


                            switch(op_relational) {
                                case "==": 
                                    if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_integer) {
                                        newValue = (((Integer) symbolValue1.valueType) == ((Integer) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_boolean) {
                                        newValue = (((Boolean) symbolValue1.valueType) == ((Boolean) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_string) {
                                        newValue = ((String) symbolValue1.valueType).equals((String) symbolValue2.valueType);
                                    }
                                break;

                                case "!=": 
                                    if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_integer) {
                                        newValue = (((Integer) symbolValue1.valueType) != ((Integer) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_boolean) {
                                        newValue = (((Boolean) symbolValue1.valueType) !=((Boolean) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_string) {
                                        newValue = !(((String) symbolValue1.valueType).equals((String) symbolValue2.valueType));
                                    }
                                break;

                                case "<" : newValue = (((Integer) symbolValue1.valueType) <  ((Integer) symbolValue2.valueType)); break;
                                case "<=": newValue = (((Integer) symbolValue1.valueType) <= ((Integer) symbolValue2.valueType)); break;
                                case ">" : newValue = (((Integer) symbolValue1.valueType) >  ((Integer) symbolValue2.valueType)); break;
                                case ">=": newValue = (((Integer) symbolValue1.valueType) >= ((Integer) symbolValue2.valueType)); break;
                            }

                            symbolRelationalComp.isConstant = true;
                            symbolRelationalComp.valueType = newValue;
                        }

                        RESULT = symbolRelationalComp; 

                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_COMP",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // COND ::= INIT_OP_BOOL 
            {
              SymbolCond RESULT =null;
		int init_op_boolleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int init_op_boolright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolInitOpBool init_op_bool = (SymbolInitOpBool)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="COND => INIT_OP_BOOL]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                String uuidTrueCondLabel = UUID.randomUUID().toString();
                String uuidFalseCondLabel = UUID.randomUUID().toString();

                stackTrueCond.push(uuidTrueCondLabel);
                stackFalseCond.push(uuidFalseCondLabel);

                SymbolInitOpBool symbolInitOpBool = init_op_bool;
                /*
                Quadruple quadrupleTrueCond = new Quadruple(OP_CODE.condTrue, symbolInitOpBool.idVariable, "" , uuidTrueCondLabel);
                quadruples.add(quadrupleTrueCond);
                
                Quadruple quadrupleFalseCond = new Quadruple(OP_CODE.condFalse, symbolInitOpBool.idVariable, "" , uuidFalseCondLabel);
                quadruples.add(quadrupleFalseCond);
                */
                RESULT = new SymbolCond();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // COND_TRUE_MASK ::= 
            {
              SymbolCondTrueMask RESULT =null;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="COND_TRUE_MASK => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_TRUE_MASK);
                        digraph.addNode(nodeGraph);
                        // =======================================================
                        /*
                        String trueCondLabel = stackTrueCond.pop();
                        Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", trueCondLabel);
                        quadruples.add(quadruple);
                        */
                        RESULT = new SymbolCondTrueMask();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_TRUE_MASK",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // COND_FALSE_MASK ::= 
            {
              SymbolCondFalseMask RESULT =null;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="COND_FALSE_MASK => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_FALSE_MASK);
                        digraph.addNode(nodeGraph);
                        // =======================================================
                        /*
                        String falseCondLabel = stackFalseCond.pop();
                        Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", falseCondLabel);
                        quadruples.add(quadruple);
                        */
                        RESULT = new SymbolCondFalseMask();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_FALSE_MASK",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // JUMP_LABEL ::= USELESS 
            {
              SymbolJumpLabel RESULT =null;
		
            /*
            String uuidLabel = UUID.randomUUID().toString();
            Quadruple quadruple = new Quadruple(OP_CODE.jump, "", "", uuidLabel);
            quadruples.add(quadruple);
            RESULT = new SymbolJumpLabel(uuidLabel);
            */
            RESULT = new SymbolJumpLabel();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("JUMP_LABEL",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // SKIP_LABEL ::= USELESS 
            {
              SymbolSkipLabel RESULT =null;
		
            /*
            String uuidLabel = UUID.randomUUID().toString();
            Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", uuidLabel);
            quadruples.add(quadruple);
            RESULT = new SymbolSkipLabel(uuidLabel);
            */
            RESULT = new SymbolSkipLabel();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SKIP_LABEL",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // COND_IF ::= inst_if COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket COND_ELIF COND_ELSE 
            {
              SymbolCondIf RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[COND_IF => inst_if COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket COND_ELIF COND_ELSE]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.COND);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.COND_TRUE_MASK);
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);
                childs.add(NodeGraph.VARIABLES.COND_ELIF);
                childs.add(NodeGraph.VARIABLES.COND_ELSE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_IF);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolCondIf();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_IF",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // COND_ELIF ::= COND_ELIF JUMP_LABEL inst_elif COND_FALSE_MASK COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolCondElif RESULT =null;
		int jump_labelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int jump_labelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		SymbolJumpLabel jump_label = (SymbolJumpLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELIF => COND_ELIF inst_elif COND_FALSE_MASK COND lbracket CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.COND_ELIF);
                    childs.add(NodeGraph.VARIABLES.COND_FALSE_MASK);
                    childs.add(NodeGraph.VARIABLES.COND);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                    childs.add(NodeGraph.VARIABLES.INSTRS);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELIF);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    /*
                    Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", jump_label.idLabel);
                    quadruples.add(quadruple);
                    */
                    RESULT = new SymbolCondElif();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELIF",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // COND_ELIF ::= 
            {
              SymbolCondElif RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELIF => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELIF);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    RESULT = new SymbolCondElif();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELIF",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // COND_ELSE ::= JUMP_LABEL inst_else lbracket CODE_BLOCK_IN COND_FALSE_MASK INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolCondElse RESULT =null;
		int jump_labelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int jump_labelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolJumpLabel jump_label = (SymbolJumpLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELSE => inst_else lbracket COND_FALSE_MASK CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                    childs.add(NodeGraph.VARIABLES.COND_FALSE_MASK);
                    childs.add(NodeGraph.VARIABLES.INSTRS);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELSE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    /*
                    Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", jump_label.idLabel);
                    quadruples.add(quadruple);
                    */
                    RESULT = new SymbolCondElse();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELSE",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // COND_ELSE ::= COND_FALSE_MASK 
            {
              SymbolCondElse RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELSE => COND_FALSE_MASK]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.COND_FALSE_MASK);
                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELSE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    RESULT = new SymbolCondElse();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELSE",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // SWITCH ::= SWITCH_BEGIN SWITCH_END 
            {
              SymbolSwitch RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[SWITCH => SWITCH_BEGIN SWITCH_END]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.SWITCH_BEGIN);
                childs.add(NodeGraph.VARIABLES.SWITCH_END);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolSwitch();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // SWITCH_BEGIN ::= SWITCH_BEGIN inst_case lparen VALUE rparen two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT inst_break final_sentence 
            {
              SymbolSwitchBegin RESULT =null;
		int switch_beginleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).left;
		int switch_beginright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).right;
		SymbolSwitchBegin switch_begin = (SymbolSwitchBegin)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-10)).value;
		int comparison_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int comparison_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolValue comparison_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[SWITCH_BEGIN => SWITCH_BEGIN inst_case lparen VALUE rparen two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT inst_break final_sentence]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.SWITCH_BEGIN);
                        childs.add(NodeGraph.VARIABLES.VALUE);
                        childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                        childs.add(NodeGraph.VARIABLES.INSTRS);
                        childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_BEGIN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolSwitchBegin symbolSwitchBegin = switch_begin;
                        SymbolValue symbolValue = comparison_value;
                        BASIC_SUBJACENT_TYPE caseBasicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                        if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            caseBasicSubjacentType = symbolValue.basicSubjacentType;

                        }else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                                ) {
                            TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                            caseBasicSubjacentType = typeDescription.basicSubjacentType;
                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in switch. The value has an incorrect type: " + symbolValue.contentDescription + "."
                            );
                        }

                        if (symbolSwitchBegin.basicSubjacentType != caseBasicSubjacentType) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in case. The value of switch and case are different. The basic subjacent type of switch is '" 
                                    + symbolSwitchBegin.basicSubjacentType + "' and the basic subjacent type of case is '" + caseBasicSubjacentType + "'."
                            );
                        }

                        RESULT = symbolSwitchBegin;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_BEGIN",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // SWITCH_BEGIN ::= inst_switch lparen VALUE rparen lbracket 
            {
              SymbolSwitchBegin RESULT =null;
		int comparison_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int comparison_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolValue comparison_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[SWITCH_BEGIN => inst_switch lparen VALUE rparen lbracket]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_BEGIN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolValue symbolValue = comparison_value;
                        BASIC_SUBJACENT_TYPE basicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                        if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            basicSubjacentType = symbolValue.basicSubjacentType;

                        }else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                                ) {
                            TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                            basicSubjacentType = typeDescription.basicSubjacentType;
                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in switch. The value has an incorrect type: " + symbolValue.contentDescription + "."
                            );
                        }

                        RESULT = new SymbolSwitchBegin(basicSubjacentType);
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_BEGIN",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // SWITCH_END ::= inst_default two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT inst_break final_sentence rbracket 
            {
              SymbolSwitchEnd RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[SWITCH_END => inst_default two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                    childs.add(NodeGraph.VARIABLES.INSTRS);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_END);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    RESULT = new SymbolSwitchEnd();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_END",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // SWITCH_END ::= rbracket 
            {
              SymbolSwitchEnd RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[SWITCH_END => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_END);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    RESULT = new SymbolSwitchEnd();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_END",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // WHILE ::= inst_while SKIP_LABEL COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolWhile RESULT =null;
		int skip_labelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int skip_labelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolSkipLabel skip_label = (SymbolSkipLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[WHILE => inst_while  INIT_OP_BOOL lbracket CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.WHILE);
                digraph.addNode(nodeGraph, childs);
                // =======================================================
                /*
                Quadruple quadrupleJump = new Quadruple(OP_CODE.jump, "", "", skip_label.idLabel);
                quadruples.add(quadrupleJump);

                String falseCondLabel = stackFalseCond.pop();
                Quadruple quadrupleSkip = new Quadruple(OP_CODE.skip, "", "", falseCondLabel);
                quadruples.add(quadrupleSkip);
                */
                RESULT = new SymbolWhile();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("WHILE",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FOR ::= inst_for CODE_BLOCK_IN lparen DECLS INIT_OP_BOOL final_sentence ASSIGN rparen lbracket INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolFor RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[FOR => inst_for CODE_BLOCK_IN lparen DECLS two_points INIT_OP_BOOL two_points ASSIGN rparen lbracket INSTRS CODE_BLOCK_OUT rbracket]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.DECLS);
                childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);
                childs.add(NodeGraph.VARIABLES.ASSIGN);
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FOR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolFor();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-11)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // CODE_BLOCK_IN ::= 
            {
              SymbolCodeBlockIn RESULT =null;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[CODE_BLOCK_IN => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CODE_BLOCK_IN);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        symbolsTable.getinBlock();
                        RESULT = new SymbolCodeBlockIn();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CODE_BLOCK_IN",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // CODE_BLOCK_OUT ::= 
            {
              SymbolCodeBlockOut RESULT =null;
		  
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[CODE_BLOCK_OUT => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CODE_BLOCK_OUT);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        symbolsTable.getoutBlock();
                        RESULT = new SymbolCodeBlockOut();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CODE_BLOCK_OUT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // FUNCTION ::= FUNC_HEAD rparen lbracket CODE_BLOCK_IN FUNC_BODY RETURN CODE_BLOCK_OUT rbracket 
            {
              SymbolFunction RESULT =null;
		int func_headleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int func_headright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolFuncHead func_head = (SymbolFuncHead)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int return_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int return_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolReturn return_val = (SymbolReturn)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[FUNCTION => FUNC_HEAD rparen lbracket CODE_BLOCK_IN INSTRS RETURN CODE_BLOCK_OUT rbracket]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.FUNC_HEAD);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.FUNC_BODY);
                childs.add(NodeGraph.VARIABLES.RETURN);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNCTION);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolFuncHead symbolFuncHead = func_head;
                SymbolReturn symbolReturn = return_val;
                TypeDescription typeDescription = symbolsTable.query(symbolFuncHead.nameType);

                if (symbolReturn == null) {
                    if (typeDescription.basicSubjacentType != BASIC_SUBJACENT_TYPE.ts_none) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Your function doesn't return a value."
                        );
                    }
                } else if (symbolReturn.basicSubjacentType != typeDescription.basicSubjacentType) {
                    throw new IncorrectTypeException(
                        CompilerException.CompilerErrorType.semantic,
                        "Your function returns an incorrect value."
                    );
                }

                RESULT = new SymbolFunction();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // FUNC_HEAD ::= inst_function id id lparen PARAMS 
            {
              SymbolFuncHead RESULT =null;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int id_functionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_functionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_function = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolParams params = (SymbolParams)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[FUNC_HEAD => inst_function id id lparen PARAMS]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.PARAMS);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNC_HEAD);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    // ================ CHECK IF TYPE IS CORRECT =========================================================
                    TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                    if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Must be a correct type."
                        );
                    }

                    if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_none
                            )
                        ) { 
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Type of variable must have a correct subjacent type."
                        ); 
                    }
                    // ==================================================================================================

                    // ============= ADD OUR FUNCTION TO DESCRIPTION TABLE ==============================================
                    TypeDescription functionTypeDescription = new TypeDescription(
                        CONTENT_DESCRIPTION.dfunc,
                        type_variable
                    );

                    symbolsTable.add(id_function, functionTypeDescription);
                    // ==================================================================================================

                    // ============= ADD PARAMS OF OUR FUNCTION TO EXPANSION TABLE ======================================
                    SymbolParams symbolParams = params;

                    ArrayList<String> listVariableIds = new ArrayList<String>();
                    ArrayList<TypeDescription> listVariableTypeDescription = new ArrayList<TypeDescription>();

                    if (symbolParams != null) {
                        listVariableIds = symbolParams.listVariableIds;
                        listVariableTypeDescription = symbolParams.listVariableTypeDescription;

                    }

                    for (int i = 0; i < listVariableIds.size(); i++) {
                        symbolsTable.addParam(id_function, listVariableIds.get(i), listVariableTypeDescription.get(i));
                    }
                    // ==================================================================================================

                    RESULT = new SymbolFuncHead(type_variable);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_HEAD",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // PARAMS ::= HAS_PARAMS 
            {
              SymbolParams RESULT =null;
		int has_paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int has_paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolHasParams has_params = (SymbolHasParams)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[PARAMS => HAS_PARAMS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.HAS_PARAMS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.PARAMS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolHasParams symbolHasParams = has_params;

                RESULT = new SymbolParams(symbolHasParams.listVariableIds, symbolHasParams.listVariableTypeDescription);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMS",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // PARAMS ::= 
            {
              SymbolParams RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[PARAMS => lambda]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.PARAMS);
                digraph.addNode(nodeGraph);
                // =======================================================

                RESULT = new SymbolParams();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMS",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // HAS_PARAMS ::= HAS_PARAMS separator id two_points id 
            {
              SymbolHasParams RESULT =null;
		int has_paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int has_paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		SymbolHasParams has_params = (SymbolHasParams)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[HAS_PARAMS => HAS_PARAMS separator id two_points id]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.HAS_PARAMS);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.HAS_PARAMS);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================


                    // ================ CHECK IF TYPE IS CORRECT =============================================================
                    TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                    if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Must be a correct type."
                        );
                    }

                    if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                            )
                        ) { 
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Type of variable must have a correct subjacent type."
                        ); 
                }
                    // =======================================================================================================
                    
                    SymbolHasParams symbolHasParams = has_params;
                    ArrayList<String> listVariableIds = symbolHasParams.listVariableIds;
                    ArrayList<TypeDescription> listVariableTypeDescription = symbolHasParams.listVariableTypeDescription;

                    TypeDescription argumentTypeDescription = new TypeDescription(
                        CONTENT_DESCRIPTION.darg,
                        type_variable
                    );

                    listVariableIds.add(id_variable);
                    listVariableTypeDescription.add(argumentTypeDescription);


                    RESULT = new SymbolHasParams(listVariableIds, listVariableTypeDescription);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("HAS_PARAMS",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // HAS_PARAMS ::= id two_points id 
            {
              SymbolHasParams RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[HAS_PARAMS => id two_points id]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.HAS_PARAMS);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    // ================ CHECK IF TYPE IS CORRECT =============================================================
                    TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                    if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Must be a correct type."
                            );
                    }

                    if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                            )
                        ) { throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Type of variable must have a correct subjacent type."
                        ); }
                    // =======================================================================================================
                    ArrayList<String> listVariableIds = new ArrayList<String>();
                    ArrayList<TypeDescription> listVariableTypeDescription = new ArrayList<TypeDescription>();

                    TypeDescription argumentTypeDescription = new TypeDescription(
                        CONTENT_DESCRIPTION.darg,
                        type_variable
                    );

                    listVariableIds.add(id_variable);
                    listVariableTypeDescription.add(argumentTypeDescription);


                    RESULT = new SymbolHasParams(listVariableIds, listVariableTypeDescription);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("HAS_PARAMS",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // FUNC_BODY ::= INSTRS 
            {
              SymbolFuncBody RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[FUNC_BODY => INSTRS]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.INSTRS);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNC_BODY);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    RESULT = new SymbolFuncBody();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_BODY",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // FUNC_BODY ::= 
            {
              SymbolFuncBody RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[FUNC_BODY => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNC_BODY);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    RESULT = new SymbolFuncBody();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_BODY",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // RETURN ::= inst_return VALUE final_sentence 
            {
              SymbolReturn RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue val = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[RETURN => inst_return VALUE final_sentence]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.VALUE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.RETURN);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolValue symbolValue = val;
                BASIC_SUBJACENT_TYPE basicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                    basicSubjacentType = symbolValue.basicSubjacentType;
                } else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                    ) {
                        TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                        basicSubjacentType = typeDescription.basicSubjacentType;
                } else {
                    throw new IncorrectTypeException(
                        CompilerException.CompilerErrorType.semantic,
                        "Error in return instruction. The value has an incorrect content description: " + symbolValue.contentDescription + "."
                    );

                }

                RESULT = new SymbolReturn(basicSubjacentType);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // RETURN ::= 
            {
              SymbolReturn RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[RETURN => lambda]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.RETURN);
                digraph.addNode(nodeGraph);
                // =======================================================

                RESULT = new SymbolReturn();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // CALL ::= inst_call lparen CALL_BODY rparen 
            {
              SymbolCall RESULT =null;
		int call_bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int call_bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolCallBody call_body = (SymbolCallBody)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
            // ============== GENERATE NODE FOR DIGRAPH ==============
            String description ="[CALL => inst_call lparen CALL_BODY rparen final_sentence]";

            ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
            childs.add(NodeGraph.VARIABLES.CALL_BODY);

            NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CALL);
            digraph.addNode(nodeGraph, childs);
            // =======================================================

            SymbolCallBody symbolCallBody = call_body;

            int numParamsCall = symbolCallBody.counter;
            int numParamsOurFunction = symbolsTable.getNumParameters(symbolCallBody.idFunction);
            
            if (numParamsCall != numParamsOurFunction) {
                throw new IncorrectTypeException(
                    CompilerException.CompilerErrorType.semantic,
                    "Error in call instruction. The number of parameters of the function '" + symbolCallBody.idFunction + "' and the call's instruction are not the same!!"
                );

            }

            RESULT = new SymbolCall(symbolCallBody.idFunction);
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // CALL_BODY ::= CALL_BODY separator VALUE 
            {
              SymbolCallBody RESULT =null;
		int call_paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int call_paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolCallBody call_params = (SymbolCallBody)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolValue val = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[CALL_BODY => CALL_BODY separator VALUE]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CALL_BODY);
                    childs.add(NodeGraph.VARIABLES.VALUE);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CALL_BODY);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    SymbolCallBody symbolCallBody = call_params;
                    SymbolValue symbolValue = val;

                    // =================== GET SUBJACENT BASIC TYPE OF OUR VALUE =========================
                    BASIC_SUBJACENT_TYPE valueBasicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                    if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                        valueBasicSubjacentType = symbolValue.basicSubjacentType;
                    } else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                        || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                        || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                        ) {
                            TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                            valueBasicSubjacentType = typeDescription.basicSubjacentType;
                    } else{
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in call instruction with function id '" + symbolCallBody.idFunction + "'.The value has an incorrect content description: " + symbolValue.contentDescription + "."
                        );

                    }
                    // ======================================================================================

                    TypeDescription parameterTypeDescription = symbolsTable.queryParam(symbolCallBody.idFunction, symbolCallBody.counter);
                    BASIC_SUBJACENT_TYPE parameterBasicSubjacentType = symbolsTable.query(parameterTypeDescription.nameType).basicSubjacentType;

                    if (parameterBasicSubjacentType != valueBasicSubjacentType) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in call instruction with function id '" + symbolCallBody.idFunction + "'. The type of parameter and your value are incorrect."
                        );
                    }

                    RESULT = new SymbolCallBody(symbolCallBody.idFunction, symbolCallBody.counter + 1);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL_BODY",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // CALL_BODY ::= id 
            {
              SymbolCallBody RESULT =null;
		int id_functionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int id_functionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id_function = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[CALL_BODY => id]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CALL_BODY);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    // Only to know if exists our function
                    symbolsTable.query(id_function);

                    RESULT = new SymbolCallBody(id_function, 0);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL_BODY",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // USELESS ::= 
            {
              SymbolUseless RESULT =null;
		
            RESULT = new SymbolUseless();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("USELESS",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
